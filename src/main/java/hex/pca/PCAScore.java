package hex.pca;

import hex.FrameTask;

import java.util.Arrays;

import water.Job.*;
import water.*;
import water.api.DocGen;
import water.fvec.*;
import water.util.RString;

/**
 * Principal Components Scoring
 * This algorithm maps a dataset into the subspace generated by the principal components.
 * If A = dataset to be scored, and B = eigenvector matrix (rows = features, cols = components),
 * then the score is simply A * B, assuming the column features match up exactly.
 * <a href = "http://en.wikipedia.org/wiki/Principal_component_analysis">PCA on Wikipedia</a>
 * @author anqi_fu
 *
 */
public class PCAScore extends FrameJob {
  static final int API_WEAVER = 1;
  static public DocGen.FieldDoc[] DOC_FIELDS;
  static final String DOC_GET = "pca_score";

  @API(help = "PCA model to use for scoring", required = true, filter = Default.class)
  PCAModel model;

  @API(help = "Number of principal components to return", filter = Default.class, lmin = 1, lmax = 10000)
  int num_pc = 1;

  @Override protected void exec() {
    // Note: Source data MUST contain all features (matched by name) used to build PCA model!
    // If additional columns exist in source, they are automatically ignored in scoring
    Frame fr = model.adapt(source, true, false)[0];
    int nfeat = model._names.length;
    boolean isStd = model.params.standardize == 1 ? true : false;

    PCAScoreTask tsk = new PCAScoreTask(this, nfeat, num_pc, model.eigVec, isStd, model.normMul, model.normSub);
    tsk.doIt(num_pc, fr);
    String[] names = new String[num_pc];
    String[][] domains = new String[num_pc][];
    for(int i = 0; i < num_pc; i++) {
      names[i] = "PC" + i;
      domains[i] = null;
    }
    DKV.put(destination_key, tsk.outputFrame(names, domains));
  }

  @Override protected void init() {
    super.init();
    if(model != null && num_pc > model.num_pc)
      throw new IllegalArgumentException("Argument 'num_pc' must be between 1 and " + model.num_pc);
  }

  /* @Override public float progress() {
    ChunkProgress progress = UKV.get(progressKey());
    return (progress != null ? progress.progress() : 0);
  } */

  public static String link(Key modelKey, String content) {
    return link("model", modelKey, content);
  }

  public static String link(String key_param, Key k, String content) {
    RString rs = new RString("<a href='/2/PCAScore.query?%key_param=%$key'>%content</a>");
    rs.replace("key_param", key_param);
    rs.replace("key", k.toString());
    rs.replace("content", content);
    return rs.toString();
  }

  // Matrix multiplication A * B, where A is a skinny matrix (# rows >> # cols) and B is a
  // small matrix that fits on a single node. For PCA scoring, the cols of A (rows of B) are
  // the features of the input dataset, while the cols of B are the principal components.
  public static class PCAScoreTask extends FrameTask<PCAScoreTask> {
    final int _nfeat;         // number of features
    final int _ncomp;         // number of principal components (<= nfeat)
    final double[][] _eigvec; // eigenvector matrix

    public PCAScoreTask(Job job, int nfeat, int ncomp, double[][] eigvec, boolean standardize) {
      super(job, standardize, false);
      _nfeat = nfeat;
      _ncomp = ncomp;
      _eigvec = eigvec;
    }

    public PCAScoreTask(Job job, int nfeat, int ncomp, double[][] eigvec, boolean standardize, double[] normMul, double[] normSub) {
      super(job, standardize, false);
      _nfeat = nfeat;
      _ncomp = ncomp;
      _eigvec = eigvec;
      _normSub = normSub;
      _normMul = normMul;
    }

    // Note: Rows with NAs (missing values) are automatically skipped!
    @Override protected void processRow(double[] nums, int ncats, int[] cats, NewChunk[] outputs) {
      for(int c = 0; c < _ncomp; c++) {
        double x = 0;
        for(int d = 0; d < ncats; d++)
          x += _eigvec[cats[d]][c];

        int k = _catOffsets[_cats];
        for(int d = 0; d < nums.length; d++)
          x += nums[d]*_eigvec[k++][c];
        assert k == _eigvec.length;
        outputs[c].addNum(x);
      }
    }

    public PCAScoreTask doIt(int outputs, Frame fr) { return dfork2(outputs, fr).getResult(); }
    public PCAScoreTask dfork2(int outputs, Frame fr) {
      if(_cats == -1 && _nums == -1 ) {
        fr = adaptFrame(fr);
        int i = 0;
        final Vec [] vecs = fr.vecs();
        final int n = vecs.length;
        while(i < n && vecs[i].isEnum())++i;
        _cats = i;
        while(i < n && !vecs[i].isEnum())++i;
        _nums = i-_cats;
        if(i != n)
          throw new RuntimeException("Incorrect format of the input frame. Frame is assumed to be ordered so that categorical columns come before numerics.");
        if(_normSub == null) _normSub = MemoryManager.malloc8d(_nums);
        if(_normMul == null) { _normMul = MemoryManager.malloc8d(_nums); Arrays.fill(_normMul, 1); }
        _catOffsets = MemoryManager.malloc4(_cats+1);
        int len = _catOffsets[0] = 0;
        for(i = 0; i < _cats; ++i)
          _catOffsets[i+1] = (len += vecs[i].domain().length - 1);
      }
      return dfork(outputs, fr);
    }
  }
}
