package h2o.samples;

import java.io.File;
import java.text.DecimalFormat;
import java.util.Random;

import water.*;
import water.fvec.*;

/**
 * Simplified version of H2O k-means algorithm for better readability.
 */
public class Part05_KMeansAPI2 {
  public static void main(String[] args) throws Exception {
    Weaver.registerPackage("h2o.samples");
    water.Boot._init.boot(new String[] { "-mainClass", UserMain.class.getName() });
  }

  public static class UserMain {
    public static void main(String[] args) throws Exception {
      H2O.main(args);
      Key file = NFSFileVec.make(new File("smalldata/gaussian/sdss174052.csv.gz"));
      Key key = Key.make("test");
      Frame frame = ParseDataset2.parse(key, new Key[] { file });
      //frame = new Frame(

      // Create k clusters as arrays of doubles
      int k = 3;
      double[][] clusters = new double[k][frame.vecs().length];

      // Initialize first cluster to random row
      Random rand = new Random();
      long row = Math.max(0, (long) (rand.nextDouble() * frame.vecs().length) - 1);
      for( int i = 0; i < frame.vecs().length; i++ )
        clusters[0][i] = frame.vecs()[i].getd(row);

      // Iterate over the dataset and show error for each step
      for( int i = 0; i < 100; i++ ) {
        KMeans task = new KMeans();
        task._clusters = clusters;
        task.invoke(frame);

        for( int c = 0; c < clusters.length; c++ ) {
          if( task._counts[c] > 0 ) {
            for( int v = 0; v < frame.vecs().length; v++ ) {
              double value = task._sums[c][v] / task._counts[c];
              clusters[c][v] = value;
            }
          }
        }
        System.out.println("Error is " + task._error);
      }

      DecimalFormat df = new DecimalFormat("#.00");

      System.out.println("Clusters:");
      for( int c = 0; c < clusters.length; c++ ) {
        for( int v = 0; v < frame.vecs().length; v++ )
          System.out.print(df.format(clusters[c][v]) + ", ");
        System.out.println("");
      }
    }
  }

  /**
   * For more complex tasks like this one, it is useful to marks fields that are provided by the
   * caller (IN), and fields generated by the task (OUT). IN fields can then be set to null when the
   * task is done using them, so that they do not get serialized back to the caller.
   */
  public static class KMeans extends MRTask2<KMeans> {
    double[][] _clusters; // IN:  Centroids/clusters

    double[][] _sums;     // OUT: Sum of features in each cluster
    int[] _counts;        // OUT: Count of rows in cluster
    double _error;        // OUT: Total sqr distance

    @Override public void map(Chunk[] chunks) {
      _sums = new double[_clusters.length][chunks.length];
      _counts = new int[_clusters.length];

      // Find nearest cluster for each row
      for( int row = 0; row < chunks[0]._len; row++ ) {
        int nearest = -1;
        double minSqr = Double.MAX_VALUE;
        for( int cluster = 0; cluster < _clusters.length; cluster++ ) {
          double sqr = 0;           // Sum of dimensional distances
          for( int column = 0; column < chunks.length; column++ ) {
            double delta = chunks[column].atd(row) - _clusters[cluster][column];
            sqr += delta * delta;
          }
          if( sqr < minSqr ) {
            nearest = cluster;
            minSqr = sqr;
          }
        }
        _error += minSqr;

        // Add values and increment counter for chosen cluster
        for( int column = 0; column < chunks.length; column++ )
          _sums[nearest][column] += chunks[column].atd(row);
        _counts[nearest]++;
      }
      _clusters = null;
    }

    @Override public void reduce(KMeans task) {
      for( int cluster = 0; cluster < _counts.length; cluster++ ) {
        for( int column = 0; column < _sums[0].length; column++ )
          _sums[cluster][column] += task._sums[cluster][column];
        _counts[cluster] += task._counts[cluster];
      }
      _error += task._error;
    }
  }
}
