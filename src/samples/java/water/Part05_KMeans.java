package water;

import hex.KMeansModel;

import java.text.DecimalFormat;
import java.util.Random;

/**
 * Simplified version of H2O k-means algorithm for better readability.
 */
public class Part05_KMeans {
  // Ignore this boilerplate main, c.f. previous samples
  public static void main(String[] args) throws Exception {
    water.Boot.main(UserMain.class, args);
  }

  public static class UserMain {
    public static void main(String[] args) throws Exception {
      // Starts a one node cluster
      H2O.main(args);

      // Load and parse a file. Data is distributed to other nodes in a round-robin way
      Key key = TestUtil.loadAndParseFile("test.hex", "lib/resources/datasets/gaussian.csv");

      // ValueArray is a distributed 2D array
      ValueArray va = DKV.get(key).get();

      // Which columns to use, use all in this case
      int[] cols = new int[va._cols.length];
      for( int i = 0; i < cols.length; i++ )
        cols[i] = i;

      // Create k clusters as arrays of doubles
      int k = 7;
      double[][] clusters = new double[k][va._cols.length];

      // Initialize clusters to random rows
      Random rand = new Random();
      for( int cluster = 0; cluster < clusters.length; cluster++ ) {
        long row = Math.max(0, (long) (rand.nextDouble() * va._numrows) - 1);
        for( int i = 0; i < cols.length; i++ )
          clusters[cluster][i] = va.datad(row, cols[i]);
      }

      // Iterate over the dataset and show error for each step
      for( int i = 0; i < 20; i++ ) {
        KMeans task = new KMeans();
        task._mainKey = key;
        task._cols = cols;
        task._clusters = clusters;
        task.invoke(key);
        System.out.println("Error is " + task._error);

        // Recompute location for each cluster
        for( int cluster = 0; cluster < clusters.length; cluster++ ) {
          if( task._counts[cluster] > 0 ) {
            for( int column = 0; column < cols.length; column++ ) {
              double value = task._sums[cluster][column] / task._counts[cluster];
              clusters[cluster][column] = value;
            }
          }
        }
      }

      System.out.println("Clusters:");
      DecimalFormat df = new DecimalFormat("#.00");
      for( int cluster = 0; cluster < clusters.length; cluster++ ) {
        for( int column = 0; column < cols.length; column++ )
          System.out.print(df.format(clusters[cluster][column]) + ", ");
        System.out.println("");
      }

      // Experimental: debug plot
      KMeansModel model = new KMeansModel(Key.make("test.kmeans"), cols, key);
      model._clusters = clusters;
      UKV.put(model._selfKey, model);
      System.out.println("Plot:");
      System.out.println("http://127.0.0.1:54321/Plot.png?source_key=test.hex&cols=0%2C1&clusters=test.kmeans");
    }
  }

  /**
   * For more complex tasks like this one, it is useful to marks fields that are provided by the
   * caller (IN), and fields generated by the task (OUT). IN fields can then be set to null when the
   * task is done using them, so that they do not get serialized back to the caller.
   */
  public static class KMeans extends MRTask {
    Key _mainKey;         // IN:  Dataset key
    int[] _cols;          // IN:  Columns in use
    double[][] _clusters; // IN:  Centroids/clusters

    double[][] _sums;     // OUT: Sum of features in each cluster
    int[] _counts;        // OUT: Count of rows in cluster
    double _error;        // OUT: Total sqr distance

    @Override public void map(Key key) {
      assert key.home();
      ValueArray va = DKV.get(_mainKey).get();
      AutoBuffer bits = va.getChunk(key);
      int rows = va.rpc(ValueArray.getChunkIndex(key));

      // Create result arrays
      _sums = new double[_clusters.length][_cols.length];
      _counts = new int[_clusters.length];
      double[] values = new double[_cols.length];

      // Find closest cluster for each row
      for( int row = 0; row < rows; row++ ) {
        // Extract a row, as it will be iterated many times
        for( int column = 0; column < _cols.length; column++ ) {
          ValueArray.Column c = va._cols[_cols[column]];
          values[column] = va.datad(bits, row, c);
        }
        // Find nearest cluster
        int nearest = -1;
        double minSqr = Double.MAX_VALUE;
        for( int cluster = 0; cluster < _clusters.length; cluster++ ) {
          double sqr = 0;           // Sum of dimensional distances
          for( int column = 0; column < _cols.length; column++ ) {
            double delta = values[column] - _clusters[cluster][column];
            sqr += delta * delta;
          }
          if( sqr < minSqr ) {
            nearest = cluster;
            minSqr = sqr;
          }
        }
        _error += minSqr;

        // Add values and increment counter for that cluster
        for( int column = 0; column < _cols.length; column++ )
          _sums[nearest][column] += values[column];
        _counts[nearest]++;
      }
      _mainKey = null;
      _cols = null;
      _clusters = null;
    }

    @Override public void reduce(DRemoteTask rt) {
      KMeans task = (KMeans) rt;
      if( _sums == null ) {
        _sums = task._sums;
        _counts = task._counts;
        _error = task._error;
      } else {
        for( int cluster = 0; cluster < _counts.length; cluster++ ) {
          for( int column = 0; column < _sums[cluster].length; column++ )
            _sums[cluster][column] += task._sums[cluster][column];
          _counts[cluster] += task._counts[cluster];
        }
        _error += task._error;
      }
    }
  }
}
