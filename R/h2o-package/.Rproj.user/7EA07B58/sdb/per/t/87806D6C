{
    "contents" : "library('RCurl');\nlibrary('rjson');\n\n# Class definitions\nsetClass(\"H2OClient\", representation(ip=\"character\", port=\"numeric\"), prototype(ip=\"127.0.0.1\", port=54321))\nsetClass(\"H2ORawData\", representation(h2o=\"H2OClient\", key=\"character\"))\nsetClass(\"H2OParsedData\", representation(h2o=\"H2OClient\", key=\"character\"))\nsetClass(\"H2OGLMModel\", representation(key=\"character\", data=\"H2OParsedData\", model=\"list\"))\nsetClass(\"H2OKMeansModel\", representation(key=\"character\", data=\"H2OParsedData\", model=\"list\"))\nsetClass(\"H2ORForestModel\", representation(key=\"character\", data=\"H2OParsedData\", model=\"list\"))\n\n# Class display functions\nsetMethod(\"show\", \"H2OClient\", function(object) {\n  cat(\"IP Address:\", object@ip, \"\\n\")\n  cat(\"Port      :\", object@port, \"\\n\")\n})\n\nsetMethod(\"show\", \"H2ORawData\", function(object) {\n  print(object@h2o)\n  cat(\"Raw Data Key:\", object@key, \"\\n\")\n})\n\nsetMethod(\"show\", \"H2OParsedData\", function(object) {\n  print(object@h2o)\n  cat(\"Parsed Data Key:\", object@key, \"\\n\")\n})\n\nsetMethod(\"show\", \"H2OGLMModel\", function(object) {\n  print(object@data)\n  cat(\"GLM Model Key:\", object@key, \"\\n\\nCoefficients:\\n\")\n  \n  model = object@model\n  print(round(model$coefficients,5))\n  cat(\"\\nDegrees of Freedom:\", model$df.null, \"Total (i.e. Null); \", model$df.residual, \"Residual\\n\")\n  cat(\"Null Deviance:    \", round(model$null.deviance,1), \"\\n\")\n  cat(\"Residual Deviance:\", round(model$deviance,1), \" AIC:\", round(model$aic,1))\n})\n\nsetMethod(\"show\", \"H2OKMeansModel\", function(object) {\n  print(object@data)\n  cat(\"K-Means Model Key:\", object@key)\n  \n  model = object@model\n  cat(\"\\n\\nK-means clustering with\", length(model$size), \"clusters of sizes \"); cat(model$size, sep=\", \")\n  cat(\"\\n\\nCluster means:\\n\"); print(model$centers)\n  cat(\"\\nClustering vector:\\n\"); print(model$cluster)  # summary(model$cluster) currently broken\n  cat(\"\\nWithin cluster sum of squares by cluster:\\n\"); print(model$withinss)\n  cat(\"\\nAvailable components:\\n\\n\"); print(names(model))\n})\n\nsetMethod(\"show\", \"H2ORForestModel\", function(object) {\n  print(object@data)\n  cat(\"Random Forest Model Key:\", object@key)\n  \n  model = object@model\n  cat(\"\\n\\nType of random forest:\", model$type)\n  cat(\"\\nNumber of trees:\", model$ntree)\n  cat(\"\\n\\nOOB estimate of error rate: \", round(100*model$oob_err, 2), \"%\", sep = \"\")\n  cat(\"\\nConfusion matrix:\\n\"); print(model$confusion)\n})\n\n# Generic method definitions\n# setGeneric(\"importFile\", function(object, path, key=\"\", header=FALSE, parse=TRUE) { standardGeneric(\"importFile\") })\nsetGeneric(\"importFile\", function(object, path, key) { standardGeneric(\"importFile\") })\n# setGeneric(\"importURL\", function(object, path, key=\"\", header=FALSE, parse=TRUE) { standardGeneric(\"importURL\") })\nsetGeneric(\"importURL\", function(object, path, key=\"\") { standardGeneric(\"importURL\") })\nsetGeneric(\"parseRaw\", function(object, key, header) { standardGeneric(\"parseRaw\") })\n# setGeneric(\"h2o.glm\", function(x, y, data, family, nfolds, alpha) { standardGeneric(\"h2o.glm\") })\nsetGeneric(\"h2o.glm\", function(x, y, data, family, nfolds = 10, alpha = 0.5, lambda = 1.0e-5) { standardGeneric(\"h2o.glm\") })\n# setGeneric(\"h2o.kmeans\", function(data, centers, iter.max) { standardGeneric(\"h2o.kmeans\") })\nsetGeneric(\"h2o.kmeans\", function(data, centers, cols = \"\", iter.max = 10) { standardGeneric(\"h2o.kmeans\") })\n# setGeneric(\"h2o.randomForest\", function(y, x_ignore, data, ntree) { standardGeneric(\"h2o.randomForest\") })\nsetGeneric(\"h2o.randomForest\", function(y, data, ntree) { standardGeneric(\"h2o.randomForest\") })\nsetGeneric(\"h2o.getTree\", function(forest, k) { standardGeneric(\"h2o.getTree\") })\n\n# Unique methods to H2O\nsetMethod(\"importURL\", signature(object=\"H2OClient\", path=\"character\", key=\"character\"),\n          function(object, path, key) {\n            res = h2o.__remoteSend(object, h2o.__PAGE_IMPORTURL, url=path)\n            # rawData = new(\"H2ORawData\", h2o=object, key=res$destination_key)\n            # if(parse)\n            #  parsedData = parseRaw(rawData, key, header)\n            res = h2o.__remoteSend(object, h2o.__PAGE_PARSE, source_key=res$key, destination_key=key)\n            while(h2o.__poll(object, res$response$redirect_request_args$job) != -1) { Sys.sleep(1) }\n            parsedData = new(\"H2OParsedData\", h2o=object, key=res$destination_key)\n          })\n\nsetMethod(\"importURL\", signature(object=\"H2OClient\", path=\"character\", key=\"ANY\"),\n          function(object, path, key) { importURL(object, path, key) })\n\nsetMethod(\"importFile\", signature(object=\"H2OClient\", path=\"character\", key=\"missing\"), \n          function(object, path) {\n            res = h2o.__remoteSend(object, h2o.__PAGE_IMPORTFILES, path=normalizePath(path))\n            # rawData = new(\"H2ORawData\", h2o=object, key=res$destination_key)\n            # if(parse)\n            #  parsedData = parseRaw(rawData, \"\", header)\n            res = h2o.__remoteSend(object, h2o.__PAGE_PARSE, source_key=res$keys[1])\n            while(h2o.__poll(object, res$response$redirect_request_args$job) != -1) { Sys.sleep(1) }\n            parsedData = new(\"H2OParsedData\", h2o=object, key=res$destination_key)\n          })\n\nsetMethod(\"importFile\", signature(object=\"H2OClient\", path=\"character\", key=\"character\"), \n          function(object, path, key) { importURL(object, paste0(\"file:///\", normalizePath(path)), key) })\n\nsetMethod(\"parseRaw\", signature(object=\"H2ORawData\", key=\"character\", header=\"logical\"), \n          function(object, key, header) {\n            res = h2o.__remoteSend(object, h2o.__PAGE_PARSE, source_key=object@key, destination_key=key, header=header*1)\n            while(h2o.__poll(object, res$response$redirect_request_args$job) != -1) { Sys.sleep(1) }\n            parsedData = new(\"H2OParsedData\", h2o=object@h2o, key=res$destination_key)\n          })\n\nsetMethod(\"h2o.glm\", signature(x=\"character\", y=\"character\", data=\"H2OParsedData\", family=\"character\", nfolds=\"numeric\", alpha=\"numeric\", lambda=\"numeric\"),\n          function(x, y, data, family, nfolds, alpha, lambda) {\n            # res = h2o.__remoteSend(data@h2o, h2o.__PAGE_GLM, key = data@key, y = y, x = paste0(x, collapse=\",\"), family = family, n_folds = nfolds, alpha = alpha, lambda = lambda)\n            res = h2o.__remoteSend(data@h2o, h2o.__PAGE_GLM, key = data@key, y = y, x = paste0(x, collapse=\",\"), family = family, n_folds = nfolds, alpha = alpha, lambda = lambda, case_mode=\"=\", case=1.0)\n            while(h2o.__poll(data@h2o, res$response$redirect_request_args$job) != -1) { Sys.sleep(1) }\n            destKey = res$destination_key\n            res = h2o.__remoteSend(data@h2o, h2o.__PAGE_INSPECT, key=res$destination_key)\n            res = res$GLMModel\n            \n            result = list()\n            result$coefficients = unlist(res$coefficients)\n            result$rank = res$nCols\n            result$family = family   # Need to convert to family object\n            result$deviance = res$validations[[1]]$resDev\n            result$aic = res$validations[[1]]$aic\n            result$null.deviance = res$validations[[1]]$nullDev\n            result$iter = res$iterations\n            result$df.residual = res$dof\n            result$df.null = res$dof + result$rank\n            result$y = y\n            result$x = x\n            \n            resGLMModel = new(\"H2OGLMModel\", key=destKey, data=data, model=result)\n            resGLMModel\n          })\n\nsetMethod(\"h2o.glm\", signature(x=\"character\", y=\"character\", data=\"H2OParsedData\", family=\"character\", nfolds=\"ANY\", alpha=\"ANY\", lambda=\"ANY\"),\n          function(x, y, data, family, nfolds, alpha, lambda) { h2o.glm(x, y, data, family, nfolds, alpha, lambda) })\n\n# setMethod(\"h2o.kmeans\", signature(data=\"H2OParsedData\", centers=\"numeric\", iter.max=\"numeric\"),\n#          function(data, centers, iter.max) {\nsetMethod(\"h2o.kmeans\", signature(data=\"H2OParsedData\", centers=\"numeric\", cols=\"character\", iter.max=\"numeric\"),\n          function(data, centers, cols, iter.max) {\n            # Build K-means model\n            res = h2o.__remoteSend(data@h2o, h2o.__PAGE_KMEANS, source_key=data@key, k=centers, max_iter=iter.max, cols=paste0(cols, collapse=\",\"))\n            while(h2o.__poll(data@h2o, res$response$redirect_request_args$job) != -1) { Sys.sleep(1) }\n            destKey = res$destination_key\n            res = h2o.__remoteSend(data@h2o, h2o.__PAGE_INSPECT, key=res$destination_key)\n            res = res$KMeansModel\n            \n            result = list()\n            if(typeof(res$clusters) == \"double\")\n              result$centers = res$clusters\n            else {\n              result$centers = do.call(rbind, res$clusters)\n              rownames(result$centers) <- seq(1,nrow(result$centers))\n              \n              if(cols[1] == \"\")\n                colnames(result$centers) <- colnames(data)\n              else {\n                # mycols = unlist(strsplit(cols, split=\",\"))\n                if(length(grep(\"^[[:digit:]]*$\", cols)) == length(cols))\n                  colnames(result$centers) <- colnames(data)[as.numeric(cols)+1]\n                else\n                  colnames(result$centers) <- cols\n              }\n            }\n            \n            # Apply model to data set\n            scoreKey = paste0(strsplit(data@key, \".hex\")[[1]], \".kmapply\")\n            res = h2o.__remoteSend(data@h2o, h2o.__PAGE_KMAPPLY, model_key=destKey, data_key=data@key, destination_key=scoreKey)\n            while(h2o.__poll(data@h2o, res$response$redirect_request_args$job) != -1) { Sys.sleep(1) }\n            result$cluster = new(\"H2OParsedData\", h2o=data@h2o, key=res$destination_key)\n            \n            # Score model on data set\n            res = h2o.__remoteSend(data@h2o, h2o.__PAGE_KMSCORE, model_key=destKey, key=data@key)\n            res = res$score\n            result$size = res$rows_per_cluster\n            result$withinss = res$sqr_error_per_cluster\n            result$tot.withinss = sum(result$withinss)\n            # Need between-cluster sum of squares (or total sum of squares, since betweenss = totss-tot.withinss)!\n            \n            resKMModel = new(\"H2OKMeansModel\", key=destKey, data=data, model=result)\n            resKMModel\n          })\n\nsetMethod(\"h2o.kmeans\", signature(data=\"H2OParsedData\", centers=\"numeric\", cols=\"numeric\", iter.max=\"ANY\"),\n          function(data, centers, cols, iter.max) { h2o.kmeans(data, centers, as.character(cols), iter.max) })\n\nsetMethod(\"h2o.kmeans\", signature(data=\"H2OParsedData\", centers=\"numeric\", cols=\"ANY\", iter.max=\"ANY\"),\n          function(data, centers, cols, iter.max) { h2o.kmeans(data, centers, cols, iter.max) })\n\n# setMethod(\"h2o.randomForest\", signature(y=\"character\", x_ignore=\"character\", data=\"H2OParsedData\", ntree=\"numeric\"),\n#          function(y, x_ignore, data, ntree) {\n#           res = h2o.__remoteSend(data@h2o, h2o.__PAGE_RF, data_key=data@key, response_variable=y, ignore=x_ignore, ntree=ntree)\nsetMethod(\"h2o.randomForest\", signature(y=\"character\", data=\"H2OParsedData\", ntree=\"numeric\"),\n          function(y, data, ntree) {\n            res = h2o.__remoteSend(data@h2o, h2o.__PAGE_RF, data_key=data@key, response_variable=y, ntree=ntree)\n            while(h2o.__poll(data@h2o, res$response$redirect_request_args$job) != -1) { Sys.sleep(1) }\n            destKey = res$destination_key\n            res = h2o.__remoteSend(data@h2o, h2o.__PAGE_RFVIEW, model_key=destKey, data_key=data@key, out_of_bag_error_estimate=1)\n                        \n            result = list()\n            result$type = \"classification\"\n            result$ntree = ntree\n            result$oob_err = res$confusion_matrix$classification_error\n            \n            rf_matrix = cbind(matrix(unlist(res$trees$depth), nrow=3), matrix(unlist(res$trees$leaves), nrow=3))\n            rownames(rf_matrix) = c(\"Min.\", \"Mean.\", \"Max.\")\n            colnames(rf_matrix) = c(\"Depth\", \"Leaves\")\n            result$forest = rf_matrix\n            \n            # Must check confusion matrix is finished calculating!\n            cf = res$confusion_matrix\n            cf_matrix = cbind(matrix(unlist(cf$scores), nrow=length(cf$header)), unlist(cf$classes_errors))\n            rownames(cf_matrix) = cf$header\n            colnames(cf_matrix) = c(cf$header, \"class.error\")\n            result$confusion = cf_matrix\n            \n            resRFModel = new(\"H2ORForestModel\", key=destKey, data=data, model=result)\n            resRFModel\n          })\n\n# setMethod(\"h2o.randomForest\", signature(y=\"character\", x_ignore=\"missing\", data=\"H2OParsedData\", ntree=\"numeric\"),\n#          function(y, data, ntree) { h2o.randomForest(y, \"\", data, ntree) })\n\nsetMethod(\"h2o.getTree\", signature(forest=\"H2ORForestModel\", k=\"numeric\"),\n          function(forest, k) {\n            if(k < 1 || k > forest@model$ntree)\n              stop(paste(\"k must be between 1 and\", forest@model$ntree))\n            res = h2o.__remoteSend(forest@data@h2o, h2o.__PAGE_RFTREEVIEW, model_key=forest@key, tree_number=k-1, data_key=forest@data@key)\n            result = list()\n            result$depth = res$depth\n            result$leaves = res$leaves\n            result\n            # Need to edit Java to output more data! Also consider plotting?\n          })\n\nsetMethod(\"summary\", signature(object=\"H2OParsedData\"),\n          function(object) {\n            res = h2o.__remoteSend(object@h2o, h2o.__PAGE_SUMMARY, key=object@key)\n            res = res$summary$columns\n            result = NULL\n            cnames = NULL\n            for(i in 1:length(res)) {\n              cnames = c(cnames, paste0(\"      \", res[[i]]$name))\n              if(res[[i]]$type == \"number\") {\n                if(is.null(res[[i]]$percentiles))\n                  params = format(rep(round(res[[i]]$mean, 3), 6), nsmall = 3)\n                else\n                  params = format(round(c(res[[i]]$min[1], res[[i]]$percentiles$values[4], res[[i]]$percentiles$values[6], res[[i]]$mean, res[[i]]$percentiles$values[8], res[[i]]$max[1]), 3), nsmall = 3)\n                  result = cbind(result, c(paste0(\"Min.   :\", params[1], \"  \"), paste0(\"1st Qu.:\", params[2], \"  \"),\n                            paste0(\"Median :\", params[3], \"  \"), paste0(\"Mean   :\", params[4], \"  \"),\n                            paste0(\"3rd Qu.:\", params[5], \"  \"), paste0(\"Max.   :\", params[6], \"  \")))                 \n                  }\n              else if(res[[i]]$type == \"enum\") {\n                col = matrix(rep(\"\", 6), ncol=1)\n                len = length(res[[i]]$histogram$bins)\n                for(j in 1:min(6,len))\n                  col[j] = paste0(res[[i]]$histogram$bin_names[len-j+1], \": \", res[[i]]$histogram$bins[len-j+1])\n                result = cbind(result, col)\n              }\n            }\n            result = as.table(result)\n            rownames(result) <- rep(\"\", 6)\n            colnames(result) <- cnames\n            result\n          })\n\nsetMethod(\"colnames\", signature(x=\"H2OParsedData\"),\n          function(x) {\n            res = h2o.__remoteSend(x@h2o, h2o.__PAGE_INSPECT, key=x@key)\n            unlist(lapply(res$cols, function(y) y$name))\n          })\n\n# setMethod(\"predict\", signature(object=\"H2OGLMModel\"), \n#          function(object) {\n#            res = h2o.__remoteSend(object@data@h2o, h2o.__PAGE_PREDICT, model_key=object@key, key=object@data@key)\n#            res = h2o.__remoteSend(object@data@h2o, h2o.__PAGE_INSPECT, key=res$response$redirect_request_args$key)\n#            result = new(\"H2OParsedData\", h2o=object@data@h2o, key=res$key)\n#          })\n\n# Internal functions & declarations\nh2o.__PAGE_EXEC = \"Exec.json\"\nh2o.__PAGE_GET = \"GetVector.json\"\nh2o.__PAGE_IMPORTURL = \"ImportUrl.json\"\nh2o.__PAGE_IMPORTFILES = \"ImportFiles.json\"\nh2o.__PAGE_INSPECT = \"Inspect.json\"\nh2o.__PAGE_JOBS = \"Jobs.json\"\nh2o.__PAGE_PARSE = \"Parse.json\"\nh2o.__PAGE_PUT = \"PutVector.json\"\nh2o.__PAGE_REMOVE = \"Remove.json\"\n\nh2o.__PAGE_SUMMARY = \"SummaryPage.json\"\nh2o.__PAGE_PREDICT = \"GeneratePredictionsPage.json\"\nh2o.__PAGE_GLM = \"GLM.json\"\nh2o.__PAGE_KMEANS = \"KMeans.json\"\nh2o.__PAGE_KMAPPLY = \"KMeansApply.json\"\nh2o.__PAGE_KMSCORE = \"KMeansScore.json\"\nh2o.__PAGE_RF  = \"RF.json\"\nh2o.__PAGE_RFVIEW = \"RFView.json\"\nh2o.__PAGE_RFTREEVIEW = \"RFTreeView.json\"\n\nh2o.__remoteSend <- function(client, page, ...) {\n  ip = client@ip\n  port = client@port\n  \n  # Sends the given arguments as URL arguments to the given page on the specified server\n  url = paste0(\"http://\", ip, \":\", port, \"/\", page)\n  temp = postForm(url, style = \"POST\", ...)\n  after = gsub(\"NaN\", \"\\\"NaN\\\"\", temp[1])\n  after = gsub(\"Inf\", \"\\\"Inf\\\"\", after)\n  res = fromJSON(after)\n  \n  if (!is.null(res$error)) {\n    myTime = gsub(\":\", \"-\", date()); myTime = gsub(\" \", \"_\", myTime)\n    h2o.__writeToFile(res, paste0(\"error_json_\", myTime, \".log\"))\n    stop(paste(url,\" returned the following error:\\n\", h2o.__formatError(res$error)))\n  }\n  res\n}\n\nh2o.__writeToFile <- function(res, fileName) {\n  cat(\"Writing JSON response to\", fileName)\n  fileConn = file(fileName)\n  \n  formatVector = function(vec) {\n    result = rep(\" \", length(vec))\n    for(i in 1:length(vec))\n      result[i] = paste0(names(vec)[i], \": \", vec[i])\n    paste(result, collapse=\"\\n\")\n  }\n  \n  writeLines(formatVector(unlist(res)), fileConn)\n  # writeLines(unlist(lapply(res$response, paste, collapse=\" \")), fileConn)\n  close(fileConn)\n}\n\nh2o.__formatError <- function(error,prefix=\"  \") {\n  result = \"\"\n  items = strsplit(error,\"\\n\")[[1]];\n  for (i in 1:length(items))\n    result = paste(result,prefix,items[i],\"\\n\",sep=\"\")\n  result\n}\n\nh2o.__poll <- function(client, keyName) {\n  res = h2o.__remoteSend(client, h2o.__PAGE_JOBS)\n  res = res$jobs\n  if(length(res) == 0) stop(\"No jobs found in queue\")\n  prog = NULL\n  for(i in 1:length(res)) {\n    if(res[[i]]$key == keyName)\n      prog = res[[i]]\n  }\n  if(is.null(prog)) stop(\"Job key \", keyName, \" not found in job queue\")\n  prog$progress\n}\n\nh2o.__exec <- function(client, expr) {\n  type = tryCatch({ typeof(expr) }, error = function(e) { \"expr\" })\n  if (type != \"character\")\n    expr = deparse(substitute(expr))\n  res = h2o.__remoteSend(client, h2o.__PAGE_EXEC, expression=expr)\n  res$key\n}\n\nh2o.__remove <- function(client, keyName) {\n  type = tryCatch({ typeof(keyName) }, error = function(e) { \"expr\" })\n  if (type != \"character\")\n    keyName = deparse(substitute(keyName))\n  res = h2o.__remoteSend(client, h2o.__PAGE_REMOVE, key=keyName)\n}",
    "created" : 1374520100977.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "205948178",
    "id" : "87806D6C",
    "lastKnownWriteTime" : 1374519962,
    "path" : "~/workspace/h2o/R/H2O.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}